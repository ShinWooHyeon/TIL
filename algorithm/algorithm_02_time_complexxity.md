# 시간 복잡도 
- 알고리즘을 비교하려면 특정한 기준이 필요하다
- 컴퓨터 실행 리소스= `CPU(시간)`,메모리, 디스크
- 같은 알고리즘인데 소요 시간 측정이 다를 수 있다 =>입력 통일 `최악의 입력n개 가정`
- **시간 복잡도**: 문제를 해결하는데 걸리는 시간과 입력의 함수 관계
    - 시간복잡도가 높다=> 느린 알고리즘/ 시간복잡도가 낮다=> 빠른 알고리즘
    - 시간복잡도 계산
        - 단순 sequence : n번 시행 -> 총 시간복잡도=n
        - 조건문 : max(<code block 1의 시간,code block 2의 시간>)
        - 반복문 : N번 반복시 코드블록 N번 실행, 중첩 반복문 rnage N,M => N*M번 실행

- **빅오(Big-O) 표기법**  
    - 입력받는 n이 무한대로 가정, 최고차항 제외 계수,상수 모두 제외, `증가율`에 초점
    <img width="455" alt="Big-O" src="https://user-images.githubusercontent.com/118239192/212868627-dc4fd1a6-ca82-4e41-b5fd-009335a38aad.png">
    - 기본 빅오 표기법 ,예시
        - O(1): 단순 산술 계산 (a+b)
        - O(logN): 크기 N인 리스트를 반절씩 조회 (`이진탐색`,분할정복)
        - O(N): 크기 N인 리스트 순회 (단일 for 문)
        - O(N**2):크기 N인 리스트 이중 순회 (M,N이면  M * N)
        - O(N**#): 3중 리스트 순회
        - O(2^N): 크기 N인 집합의 부분집합
        - O(N!): 크기 N 리스트의 순열
    **즉 주어진 상황에서 시간복잡도를 줄이며 성능 높이는 것이 문제해결의 포인트**


# 리스트
- 배열 (Array): 여러 데이터들이 연속된 메모리 공간에 저장되어있는 자료구조
- 배열의 길이는 변경 불가능,길이 변경 원하면 새로 생성
- 데이터 타입은 고정    
## 연결 리스트
- 데이터가 담긴 여러 노드들이 순차적으로 연결된 형태의 자료구조
- 연결리스트 길이 자유롭게 변경 가능 , 데이터에 메모리가 연속적으로 저장되지 않음 
## 파이썬 리스트의 주요 메소드 및 함수
- 메소드
    - .append() :리스트 끝에 새로운 원소 삽입
    - .pop(인덱스) : 특정 인덱스 원소 `삭제 및 반환`
    - .count(원소): 리스트에서 해당 원소의 개수 반환
    - .index(원소): 처음으로 원소 등장하는 인덱스 반환
    - .sort(): 리스트를 오름차순으로 정렬 (reverse=True 이용시 내림차순 가능)
    - .reverse(): 리트스 원소 순서 거꾸로 뒤집기
- 내장함수
    - len(): 리스트의 길이 반환
    - sum(): 리스트 요소들의 합 반환
    - max(): 리스트 요소 중 최댓값 반환
    - min(): 리스트 요소 중 최소값 반환
    - sorted(): 오름차순으로 정렬된 `새로운 리스트 ` 반환 , 원본 리스트 변화 x
    - reversed(): 순서 거꾸로 뒤집어진 `새로운 리스트`반환, 원본 리스트 변화 x


