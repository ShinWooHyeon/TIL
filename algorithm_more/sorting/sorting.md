# 정렬
- 정렬이란 데이터를 특정한 기준에 따라서 순서대로 나열하는 것을 의미한다.
- 정렬 알고리즘은 이진 탐색의 전처리 과정이기도 해서 중요하다
- 내림차순 정렬은 오름차순 정렬 수행 알고리즘의 크기 비교를 반대로만 하면 된다.
- 리스트의 reverse 정렬 역시 시간 복잡도가 O(N)이기 때문에 간단히 수행할 수 있다.

## 선택 정렬
- 가장 원시적인 정렬 알고리즘, 가장 작은 데이터를 선택해 맨 앞 데이터와 바꾸고, 그 다음 작은 데이터를 두 번째 데이터와 순서를 바꾸는 정렬
```python
array=[7,5,9,0,3,1,6,2,4,8]

for i in range(len(array)):
    for j in range(i+1,len(array)):
        if array[i]>array[j]:
            array[i],array[j]=array[j],array[i]

```
- 선택 정렬의 시간 복잡도는 `O(N^2)` , 단순하게 N회, N-1회... 2회 이므로 
- 다른 알고리즘에 비해 비효율적이지만 , 특정한 리스트에서 가장 작은 데이터 찾는 경우 파악할 필요가 있다.

## 삽입정렬
- 삽입정렬 역시 선택정렬과 마찬가지로 직관적인 정렬 알고리즘이다. 특정한 데이터를 `적절한 위치에 삽입` 하는 것이 삽입정렬이다
- 삽입정렬의 경우 특정한 데이터 앞까지의 데이터는 이미 정렬되어 있다고 가정한다
- 즉 삽입정렬의 경우 두 번째 데이터부터 정렬을 시작한다 (첫 번째 데이터는 이미 정렬되어 있다고 가정)
- 삽입정렬의 예시  
    - EX > 7, 5, 9, 0, 3, 1 , 6, 2, 4, 8 을 삽입정렬하고자 한다
        1. 두 번째 데이터 5가 어디로 들어갈지 결정 (첫 번째 데이터까지의 왼쪽 오른쪽만 선택 가능=> 7 왼쪽  ) => 5, 7, 9, 0, 3, 1 , 6, 2, 4, 8
        2. 세 번째 데이터 9가 어디로 들어갈지 결정 (두 번째 데이터까지의 왼쪽 오른쪽만 선택 가능=>7 오른쪽 ) => 5, 7, 9, 0, 3, 1 , 6, 2, 4, 8
        3. 네 번째 데이터 0 결정 (5의 왼쪽) =>0, 5, 7, 9, 3, 1 , 6, 2, 4, 8
        4. 다섯 번째 데이터 3 결정 (5의 왼쪽) =>0, 3, 5, 7, 9, 1, 6, 2, 4, 8
        5. 여섯 번째 데이터 1 결정 (3의 왼쪽) =>0, 1, 3, 5, 7, 9, 6, 2, 4, 8
        6. 일곱 번째 데이터 6 결정 (7의 왼쪽) =>0, 1, 3, 5, 6, 7, 9, 2, 4, 8
        7. 여덟 번째 데이터 2 결정 (3의 왼쪽) =>0, 1, 2, 3, 5, 6, 7, 9, 4, 8
        8. 아홉 번째 데이터 4 결정 (5의 왼쪽) =>0, 1, 2, 3, 4, 5, 6, 7, 9, 8
        9. 열 번째 데이터 8 결정   (9의 왼쪽) =>0, 1, 2, 3, 4, 5, 6, 7, 8, 9

- 삽입정렬의 특징: 정렬이 이루어진 원소는 항상 오름차순을 유지한다는 것이다.
- 즉, 정렬하고자 하는 데이터가 한 칸씩 왼쪽으로 이동하다 자기보다 작은 데이터를 만났다면 더 이상 살펴볼 필요 없이 그 자리에 삽입되는 것이다.
```python
array=[7,5,9,0,3,1,6,2,4,8]
for i in range(1,len(array)):
    for j in range(i,0,-1):
        if array[j]<array[j-1]:
            array[j],array[j-1]=array[j-1],array[j]
        else:
            break
print(array)
```
- 삽입 정렬의 시간 복잡도 역시 O(N^2)이지만 최선의 경우 시간복잡도 O(N)을 가진다. 즉 거의 정렬되어 있는 상태로 입력이 주어지는 문제라면
삽입 정렬이 다른 퀵정렬등의 알고리즘보다 강력하다 (거의 break 되기 때문에)

## 퀵 정렬 
- 정렬 라이브러리의 근간이 되는 알고리즘 
- 기준 데이터를 설정하고 그 기준보다 큰 데이터와 작은 데이터의 위치를 바꾼다 
- 데이터를 교환하기 위한 기준을 `피벗`이라고 한다.
- 리스트에서는 첫 번째 데이터를 피벗으로 정한다.
- 이후 `왼쪽에서부터 피벗보다 큰 데아터`를, `오른쪽에서부터는 피벗보다 작은 데이터`를 찾는다
- 퀵 정렬은 크게 3가지 파트로 진행된다
- 퀵 정렬의 예시
    - EX> 5, 7, 9, 0, 3, 1, 6, 2, 4, 8 을 퀵정렬하고자 한다
    - PART 1
     1. 피벗은 리스트의 첫번째 요소 `5`이므로 왼쪽에서 5보다 큰 7이 오른쪽에서는 5보다 작은 4가 선택되고 서로 변경한다 
        =>5, 4, 9, 0, 3, 1, 6, 2, 7, 8
     2. 위 과정을 다시 반복하면 왼쪽에서는 9 오른쪽에서는 2가 선택되고 서로 변경된다 =>5, 4, 2, 0, 3, 1, 6, 9, 7, 8
     3. 다시 반복하면 왼쪽에서는 6이 오른쪽에서는 1이 선택되는데 왼쪽에서 고른 6이 더 오른쪽에 있는 경우, 즉 `엇갈린 경우`
       작은 데이터와 피벗의 데이터를 변경한다 (그래야 작은데이터가 피벗보다 앞에오고 오른쪽은 이미 피벗보다 크게 정렬했기 때문)
       =>1, 4, 2, 0, 3, 5, 6, 9, 7, 8
    - PART 1 ,즉 이 과정을 거치면 피벗을 기준으로 작은 데이터는 왼쪽, 큰 데이터는 오른쪽에 오게 된다 이 과정이 Partion이다
    - PART 2는 PART1 과정을 피벗기준으로 왼쪽에서도 진행한다
    - PART 3는 PART1 과정을 피벗기준으로 오른쪽에서도 진행한다.
    - 퀵 정렬이 끝나는 경우는 리스트의 원소가 1개일 경우이다 (이미 정렬되어 있다고 판단하기 때문이다 )
```python
array=[5, 7, 9, 0,3,1,6,2,4,8]
def quick_sort(array,start,end):
    if start>=end: #원소가 1개인 경우 종료
        return
    pivot=start # 피벗은 첫 번째 원소이다
    left=start+1 #피벗 오른쪽에서 시작, 
    right=end   # 끝에서 부터 
    while left <= right :# 엇갈리지 않는 동안
        #왼쪽에서는 피벗보다 큰 데이터를 찾을 때 까지 left를 증가시킨다 
        while left<=end and array[left] <=array[pivot]:
            left +=1
        #오른쪽에서는 피벗보다 작은 데이터를 찾을 때 까지 right를 감소시킨다
        while (right>start) and (array[right]>=array[pivot]):
            right -=1
        
        # 현재 while문을 돌아 왼쪽에서 큰 데이터, 오른쪽에서 작은 데이터를 찾은 상황
        if left>right : #만약 엇갈렸다면
            array[right] , array[pivot] =array[pivot],array[right]
        else: #엇갈리지 않았다면
            array[right] , array[left]= array[left], array[right]
    
    # 위 작업이 quick sort 1차 분할 현재 피벗(right),기준,left의 형태일거임 근데 이 경우 right의 위치가 피벗의 위치가 됨 작은값이니까 
    # 위 작업을 왼쪽 오른족에서 진행
    quick_sort(array,start,right-1)
    quick_sort(array,right+1,end)

quick_sort(array,0,len(array)-1) # 인덱스니까 0부터 길이까지가 아니라 길이-1로 해야 가능
print(array)
``` 
- 위 코드는 전통적인 퀵 정렬의 소스코드이며, 파이썬의 장점을 살린 퀵 정렬 소스코드는 다음과 같다
```python
array=[5, 7, 9, 0,3,1,6,2,4,8]
def quick_sort(array):
    #리스트가 하나의 원소만을 담고 있으면 종료
    if len(array)<=1:
        return array
    pivot=array[0] #피벗은 첫 번째 원소이며
    tail=array[1:] #피벗을 제외한 리스트

    leftside=[x for x in tail if x<=pivot] #분할된 왼쪽부분
    rightside=[x for x in tail if x>pivot] # 분할된 오른 쪽 부분
    return quick_sort(leftside) + [pivot] + quick_sort(rightside)

print(quick_sort(array))
```
- 퀵 정렬의 시간 복잡도는 O(NlogN)이며 최악의 경우 O(N^2)이다. 퀵정렬의 경우 데이터가 정렬되어 있을 경우 매우 느리게 작동하며
 삽입정렬과 대비되는 이유이다 .

 ## 계수 정렬
 - 계수 정렬은 특정한 조건이 부합할 때 사용할 수 있으며 매우 빠른 정렬 알고리즘이다.
 - 모든 데이터가 양의 정수, 데이터의 개수가 N, 최댓값이 K일 경우 O 최악의 경우에도 (N+K)의 수행시간을 보장한다.
 - 데이터의 크기가 `정수로 제한` 되어 있을 때 사용할 수 있다, 다만 가장 큰 데이터와 가장 작은 데이터의 차이가 너무 크면 계수정렬은 사용할 수 없다.
 - 그 이유는 모든 범위를 담을 수 있는 크기의 리스트를 선언해야하기 때문이다.
 - 계수 정렬은 비교하는 알고리즘이 아닌 리스트를 선언하고 그 안에 정보를 담는다는 특징이 있다 .
 - 가장 큰 데이터와 가장 작은 데이터의 범위가 모두 담길 수 있도록 리스트를 선언한 후 , 데이터를 확인하며 동일한 인덱스의 데이터를 1씩 증가시킨다.
 - 정렬된 결과를 확인하고자 하면 인덱스의 값의 횟수만큼 그 값을 출력하면 된다. 
 - 현존하는 정렬중 기수 정렬과 함꼐 가장 빠르다고 할 수 있다
 - 계수정렬은 그러나 때에 따라 `굉장한 비효율성`을 초래할 수 있다. 데이터가 단 2개 있지만 그 크기가 100만이상일 경우 리스트의 크기를 100만이 되도록 설정해야 하는 등 어려움이 있을 수 있다. 계수정렬의 공간복잡도 역시 O(N+K)이다.

 ## 파이썬의 정렬 라이브러리
 - 파이썬은 기본 정렬 라이브러리인 sorted()를 제공한다. sorted()는 퀵 정렬과 비슷한 병합정렬 방식의 기반이며 시간복잡도 O(NlogN)을 보장한다. 
 - sorted의 경우 key 값을 통하여 정렬 할 수 있다.
 ```python
 strs=['아이유','iu','이지금유튜브']
print(strs.sorted(key=len))

songs=[('팔레트트트트',4),('좋은날',1),('스물',3),('너랑나랑',2)]
ans=sorted(songs,key=lambda x: (len(x[0]),x[1]))
print(ans)
 ```
- 정렬 라이브러리는 항상 최악의 경우에도 시간 복잡도 O(NlogN)을 보장한다. 
- 문제에서 별도의 요구가 없는 단순 정렬은 `정렬 라이브러리`, 데이터의 범위가 한정 되어 있으면 `계수 정렬`을 사용한다
- 코딩테스트에서는 정렬 알고리즘에 대해 크게 3가지 유형으로 출제된다
    1. 정렬 라이브러리로 풀 수 있는 문제
    2. 정렬 알고리즘의 원리에 대해서 물어보는 문제(선택 정렬, 삽입 정렬, 퀵 정렬 등의 원리를 알고 있어야 한다)
    3. 더 빠른 정렬 알고리즘을 이용하거나 기존에 알려진 알고리즘의 구조적인 개선을 거쳐야 풀 수 있다. 
    